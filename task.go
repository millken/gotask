package gotask

import (
	"context"
	"time"
)

var (
	Zero   = int64(0)
	RunNow = int64(100)
)

// TaskFunc is the user defined function to execute as part of this task.
type TaskFunc func(context.Context) error

type Task interface {
	// Next returns the next time this schedule is activated, If no time can be found to satisfy the schedule, return the zero time.
	Next() int64
	SetTaskFunc(taskFunc TaskFunc)
	Func(context.Context) error
}

type baseTask struct {
	TaskFunc
}

func (t *baseTask) SetTaskFunc(taskFunc TaskFunc) {
	t.TaskFunc = taskFunc
}
func (t *baseTask) Func(ctx context.Context) error {
	if t.TaskFunc != nil {
		return t.TaskFunc(ctx)
	}
	return nil
}

type OnceTask struct {
	baseTask
	done bool
	opt  option
}

var _ Task = (*OnceTask)(nil)

func NewOnceTask(opts ...Option) (*OnceTask, error) {
	var opt option
	for _, o := range opts {
		if err := o(&opt); err != nil {
			return nil, err
		}
	}
	return &OnceTask{opt: opt}, nil
}

func (t *OnceTask) Next() int64 {
	if !t.done {
		t.done = true
		if t.opt.Delay > 0 {
			return time.Now().Unix() + int64(t.opt.Delay/time.Second)
		}
		return RunNow
	}
	return Zero

}

// type task struct {
// 	sync.Mutex

// 	// id is the Unique ID created for each task. This ID is generated by the Add() function.
// 	id string

// 	// Interval is the frequency that the task executes. Defining this at 30 seconds, will result in a task that
// 	// runs every 30 seconds.
// 	//
// 	// The below are common examples to get started with.
// 	//
// 	//  // Every 30 seconds
// 	//  time.Duration(30 * time.Second)
// 	//  // Every 5 minutes
// 	//  time.Duration(5 * time.Minute)
// 	//  // Every 12 hours
// 	//  time.Duration(12 * time.Hour)
// 	//  // Every 30 days
// 	//  time.Duration(30 * (24 * time.Hour))
// 	//
// 	Interval time.Duration

// 	// RunOnce is used to set this task as a single execution task. By default, tasks will continue executing at
// 	// the interval specified until deleted. With RunOnce enabled the first execution of the task will result in
// 	// the task self deleting.
// 	RunOnce bool

// 	// StartAfter is used to specify a start time for the scheduler. When set, tasks will wait for the specified
// 	// time to start the schedule timer.
// 	StartAfter time.Time

// 	//Cron is used to specify a cron expression for the scheduler. When set, tasks will wait for the specified time to start the schedule timer.
// 	Cron string

// 	// TaskFunc is the user defined function to execute as part of this task.
// 	TaskFunc func(context.Context) error

// 	// ErrFunc allows users to define a function that is called when tasks return an error. If ErrFunc is nil,
// 	// errors from tasks will be ignored.
// 	ErrFunc func(error)

// 	// timer is the internal task timer. This is stored here to provide control via main scheduler functions.
// 	timer *time.Timer

// 	// ctx is the internal context used to control task cancelation.
// 	ctx context.Context

// 	// cancel is used to cancel tasks gracefully. This will not interrupt a task function that has already been
// 	// triggered.
// 	cancel context.CancelFunc
// }

// // NewTask creates a new task instance. This is the main entry point for the package.
// func NewTask() *Task {
// 	ctx, cancel := context.WithCancel(context.Background())
// 	return &Task{
// 		ctx:    ctx,
// 		cancel: cancel,
// 	}
// }

// // Start starts the task. This function will start the task timer and execute the task function.
// func (t *Task) Start(ctx context.Context) {
// 	t.Lock()
// 	defer t.Unlock()
// 	t.timer = time.AfterFunc(t.Interval, t.run)
// }

// // Stop stops the task. This function will stop the task timer and cancel the task context.
// func (t *Task) Stop() {
// 	t.Lock()
// 	defer t.Unlock()
// 	t.timer.Stop()
// 	t.cancel()
// }

// // run is the internal function that executes the task function. This function is called by the task timer.
// func (t *Task) run() {
// 	err := t.TaskFunc()
// 	if err != nil && t.ErrFunc != nil {
// 		t.ErrFunc(err)
// 	}

// 	if t.RunOnce {
// 		t.Stop()
// 		return
// 	}

// 	t.Start()
// }
